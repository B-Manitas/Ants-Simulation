CXX=clang++-7
CXXFLAGS= -Wall -std=c++11 -g -O3
EXEC_FILES= test coord ensCoord
SRC= $(wildcard *.cpp)
OBJ=$(SRC:.cpp=.o)

all: $(EXEC_FILES)

%.o: %.cpp
	$(CXX) -o $@ -c $< $(CFLAGS

test: $(OBJ)
	$(CXX) -o $@ $^ $(LDFLAGS)

$(OBJ): test.cpp

check: test
	./test -e

clean:
	rm -f $(OBJ) $(EXEC_FILES)



============
test: test.o coord.o
	$(CXX) -o $@ $^ $(LDFLAGS)

============
TEST_CASE("Test du constructeur de la class Grille.")
{

  CHECK(Grille(1).grille == std::vector<std::vector<Place>>({{Place(Coord(0, 0))}}));
  CHECK(Grille(2).grille == std::vector<std::vector<Place>>({{Place(Coord(0, 0)), Place(Coord(1, 0))},
                                                             {Place(Coord(1, 0)), Place(Coord(1, 1))}}));

  // CHECK(Grille(2).grille == EnsCoord({Coord(0, 0), Coord(1, 0), Coord(1, 0), Coord(1, 1)}));
}

=========


{
  Coord coordF = fourmi.getCoord();

  Place pf = laGrille.chargePlace(coordF);
  EnsCoord voisCoord = voisines(coordF);

  for (int numRegle = 0; numRegle < 5; numRegle++)
    for (int i = 0; i < voisCoord.taille(); i++)
    {
      Place vois = laGrille.chargePlace(voisCoord.ieme(i));
      if (Action().condtion_n(numRegle, fourmi, pf, vois))
      {
        Action().action_n(numRegle, fourmi, pf, vois);
        laGrille.rangePlace(pf);
        laGrille.rangePlace(vois);
        return;
      }
    }
}

==============
    // dessineVecteur(lesFourmis.m_grilleF);

    // std::cout << "\nSimu: " << i << std::endl;
    // std::cout << std::endl;
    // std::cout << "Les Fourmis: " << lesFourmis << std::endl;
    // std::cout << std::endl;
    // std::cout << "Les Fourmis: " << lesFourmis << std::endl;
    // std::cout << "\nFin" << std::endl;

==========
// void initialiserEmplacements(Grille &laGrille, GrilleFourmis &lesFourmis);
// void dessine2DVecteur(std::vector<std::vector<Fourmi>> &t);

=============
void initialiserEmplacements(Grille &laGrille, GrilleFourmis &lesFourmis)
{
  EnsCoord centre = EnsCoord();
  int idF = 0;
  for (int y = TAILLEGRILLE / 2 - 2; y < TAILLEGRILLE / 2 + 2; y++)
    for (int x = TAILLEGRILLE / 2 - 2; x < TAILLEGRILLE / 2 + 2; x++)
    {
      Coord c = Coord(x, y);
      centre.ajoute(c);
      if (x >= TAILLEGRILLE / 2 - 1 && x < TAILLEGRILLE / 2 + 1 && y >= TAILLEGRILLE / 2 - 1 && y < TAILLEGRILLE / 2 + 1)
      {
        Place pNid = Place(c);
        pNid.poseNid();
        laGrille.rangePlace(pNid);
      }
      else
      {
        Place pF = Place(c);
        Fourmi f = Fourmi(c, idF);
        pF.poseFourmi(f);
        laGrille.rangePlace(pF);
        lesFourmis.rangeFourmi(f);
        idF++;
      }
    }

  Place pSucre = laGrille.randPlace();

  while (centre.contient(pSucre.getCoord()))
    pSucre = laGrille.randPlace();

  pSucre.poseSucre();
  laGrille.rangePlace(pSucre);
  testCoherence(laGrille, lesFourmis, "Initialisation");
}

===================
TEST_CASE("Test des mÃ©thodes de la classe Place.")
{
  Coord c = Coord(0, 0);
  Place p = Place(Coord(0, 0));
  CHECK_FALSE(p.contientSucre());
  CHECK_FALSE(p.contientNid());
  CHECK_FALSE(p.contientFourmi());
  CHECK_FALSE(p.estSurUnePiste());
  CHECK(p.estVide());
  p.poseFourmi(Fourmi(c, 0));
  CHECK(p.contientFourmi());
  CHECK(p.getNumeroFourmi() == 0);
  p.enleveFourmi();
  p.poseSucre();
  CHECK(p.contientSucre());
  p.enleveSucre();
  p.poseNid();
  CHECK(p.contientNid());
  p.poseFourmi(Fourmi(c, 0));
  // CHECK_THROWS_AS(p.poseFourmi(Fourmi(c, 0)), std::runtime_error);
  CHECK_FALSE(p.contientFourmi());
  p.enleveSucre();
  CHECK_FALSE(p.contientFourmi());
  p.posePheroNid(2);
  CHECK(p.getPheroNid() == 1);
  p.posePheroSucre(300);
  CHECK(p.getPheroSucre() == 255);
  p.diminuerPheroSucre();
  CHECK(p.getPheroSucre() == 250);
}