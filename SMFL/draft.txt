CXX=clang++-7
CXXFLAGS= -Wall -std=c++11 -g -O3
EXEC_FILES= test coord ensCoord
SRC= $(wildcard *.cpp)
OBJ=$(SRC:.cpp=.o)

all: $(EXEC_FILES)

%.o: %.cpp
	$(CXX) -o $@ -c $< $(CFLAGS

test: $(OBJ)
	$(CXX) -o $@ $^ $(LDFLAGS)

$(OBJ): test.cpp

check: test
	./test -e

clean:
	rm -f $(OBJ) $(EXEC_FILES)



============
test: test.o coord.o
	$(CXX) -o $@ $^ $(LDFLAGS)

============
TEST_CASE("Test du constructeur de la class Grille.")
{

  CHECK(Grille(1).grille == std::vector<std::vector<Place>>({{Place(Coord(0, 0))}}));
  CHECK(Grille(2).grille == std::vector<std::vector<Place>>({{Place(Coord(0, 0)), Place(Coord(1, 0))},
                                                             {Place(Coord(1, 0)), Place(Coord(1, 1))}}));

  // CHECK(Grille(2).grille == EnsCoord({Coord(0, 0), Coord(1, 0), Coord(1, 0), Coord(1, 1)}));
}

=========


{
  Coord coordF = Ant.getCoord();

  Place pf = laGrille.chargePlace(coordF);
  EnsCoord voisCoord = voisines(coordF);

  for (int numRegle = 0; numRegle < 5; numRegle++)
    for (int i = 0; i < voisCoord.taille(); i++)
    {
      Place vois = laGrille.chargePlace(voisCoord.nth(i));
      if (Action().condtionNth(numRegle, Ant, pf, vois))
      {
        Action().actionNth(numRegle, Ant, pf, vois);
        laGrille.setPlace(pf);
        laGrille.setPlace(vois);
        return;
      }
    }
}

==============
    // dessineVecteur(lesAnts.m_grid);

    // std::cout << "\nSimu: " << i << std::endl;
    // std::cout << std::endl;
    // std::cout << "Les Ants: " << lesAnts << std::endl;
    // std::cout << std::endl;
    // std::cout << "Les Ants: " << lesAnts << std::endl;
    // std::cout << "\nFin" << std::endl;

==========
// void initializeRandomPlaces(Grille &laGrille, GridAnts &lesAnts);
// void dessine2DVecteur(std::vector<std::vector<Ant>> &t);

=============
void initializeRandomPlaces(Grille &laGrille, GridAnts &lesAnts)
{
  EnsCoord centre = EnsCoord();
  int idF = 0;
  for (int y = GRID_SIZE / 2 - 2; y < GRID_SIZE / 2 + 2; y++)
    for (int x = GRID_SIZE / 2 - 2; x < GRID_SIZE / 2 + 2; x++)
    {
      Coord c = Coord(x, y);
      centre.ajoute(c);
      if (x >= GRID_SIZE / 2 - 1 && x < GRID_SIZE / 2 + 1 && y >= GRID_SIZE / 2 - 1 && y < GRID_SIZE / 2 + 1)
      {
        Place pNid = Place(c);
        pNid.putAntNest();
        laGrille.setPlace(pNid);
      }
      else
      {
        Place pF = Place(c);
        Ant f = Ant(c, idF);
        pF.putAnt(f);
        laGrille.setPlace(pF);
        lesAnts.setAnt(f);
        idF++;
      }
    }

  Place pSucre = laGrille.getRandPlace();

  while (centre.contient(pSucre.getCoord()))
    pSucre = laGrille.getRandPlace();

  pSucre.putSugar();
  laGrille.setPlace(pSucre);
  testCoherence(laGrille, lesAnts, "Initialisation");
}

===================
TEST_CASE("Test des mÃ©thodes de la classe Place.")
{
  Coord c = Coord(0, 0);
  Place p = Place(Coord(0, 0));
  CHECK_FALSE(p.isContainingSugar());
  CHECK_FALSE(p.isContainingAntNest());
  CHECK_FALSE(p.isContainingAnt());
  CHECK_FALSE(p.estSurUnePiste());
  CHECK(p.estVide());
  p.putAnt(Ant(c, 0));
  CHECK(p.isContainingAnt());
  CHECK(p.getIdAnt() == 0);
  p.removeAnt();
  p.putSugar();
  CHECK(p.isContainingSugar());
  p.removeSugar();
  p.putAntNest();
  CHECK(p.isContainingAntNest());
  p.putAnt(Ant(c, 0));
  // CHECK_THROWS_AS(p.putAnt(Ant(c, 0)), std::runtime_error);
  CHECK_FALSE(p.isContainingAnt());
  p.removeSugar();
  CHECK_FALSE(p.isContainingAnt());
  p.putPheroAntNest(2);
  CHECK(p.getPheroAntNest() == 1);
  p.putPheroSugar(300);
  CHECK(p.getPheroSucre() == 255);
  p.decreasePheroSugar();
  CHECK(p.getPheroSucre() == 250);
}

=============================================
        else if (not isPputing && w_event.mouseButton.button == sf::Mouse::Right)
        {
          int x = double(w_event.mouseButton.x) / TAILLE_CASE;
          int y = double(w_event.mouseButton.y) / TAILLE_CASE;

          if (y > 0 and x > 0 and y < GRID_SIZE and x < GRID_SIZE)
          {
            Place mouse_place = laGrille.chargePlace(Coord(x, y));

            Ant mouse_Ant = Ant(Coord(x, y), lesAnts.nouvelleId());
            if (mouse_place.isContainingAnt() && lesAnts.isContainingAntsCoord(Coord(x, y)))
            {

              lesAnts.supprime(lesAnts.position());
              mouse_place.removeAnt();
              grid_state[y][x] = int(state_boxes::vide);
            }

            else if (mouse_place.estVide() and mouse_place.putAnt(mouse_Ant))
            {
              lesAnts.setAnt(mouse_Ant);
              grid_state[y][x] = int(state_boxes::Ant);
            }

            laGrille.setPlace(mouse_place);
          }
        }

====================
int GridAnts::nouvelleId()
{
  std::vector<int> id_existant;
  int new_id = 0;

  for (size_t i = 0; i < taille(); i++)
    id_existant.push_back(m_grid[i].getNum());

  while (std::find(id_existant.begin(), id_existant.end(), new_id) == id_existant.end())
    new_id = rand() % 10000;
}